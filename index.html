<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#317EFB">
<title>BG Tracker</title>
<style>
/* ===== PAGE LAYOUT ===== */
body { margin:0; font-family:Inter,system-ui,Arial; background:#1b1b1b; color:#fff; padding:18px }
.heading { font-size:28px; font-weight:800; margin:20px 0 12px; color:#fff }
.headingTitle { font-size:16px; font-weight:700;gap:10px; margin:-12px 0 -20px; color:#000;
 text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  -webkit-background-clip: text;
     -moz-background-clip: text;
          background-clip: text;
position: sticky;
  top: 0;
  z-index: 1000;
  background: rgba(27, 27, 27, 0.9); /* matches page background */
  backdrop-filter: blur(2px);            /* soft blur for modern look */
  padding: 2px 0;
  text-align: center;
   text-align:right }

/* ===== PAGE SECTIONS ===== */
.input-section { margin-bottom:18px } /* slightly reduced to fit new summary spacing */
.chart-section { padding:18px; margin-bottom:28px }
.stats-section { margin-bottom:28px }

/* ===== SUMMARY PANEL ===== */
.summary-panel { display:flex; gap:12px; align-items:center; justify-content:flex-start; margin:18px 0; padding:10px 12px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.12)); color:#fff; box-shadow: 0 8px 20px rgba(0,0,0,0.35); font-size:14px; flex-wrap:nowrap; }
.summary-panel .stat { color:rgba(255,255,255,0.9); white-space:nowrap; flex:1; text-align:center }
.summary-panel .stat .label { display:inline-block; margin-right:6px; color:rgba(255,255,255,0.7); font-weight:600; font-size:13px; }
.summary-panel .stat .value { font-weight:800; font-size:18px; color:#00ffcc }

/* ===== GRID LAYOUT ===== */
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(100px,1fr)); gap:10px }
.chip, .select-btn { padding:14px 14px; background:#222; cursor:pointer; text-align:center; font-size:16px; color:#fff; border:white}
.chip.active, .select-btn.active { background:#fff; color:#000; }
.save-wrap {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 12px;
}

.save-btn {
  position: relative;               /* needed for absolute checkmark */
  width: 100%;                      /* full width */
  padding: 22px 22px;               /* touch-friendly padding */
  display: flex;
  align-items: center;
  justify-content: center;           /* center text perfectly */
  background: linear-gradient(135deg, #00ff99, #00cccc);
  color: #000;
  font-weight: 900;
  font-size: 16px;
  border: 0;
  border-radius: 8px;
  cursor: pointer;
  overflow: hidden;                  /* ensures checkmark stays inside button */
}

/* Button text */
.save-btn span {
  pointer-events: none;              /* optional: prevent text interference */
}

/* Checkmark */
.save-btn .checkmark {
  position: absolute;                /* removed from flex flow */
  right: 16px;                       /* adjust distance from right edge */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.6);
  transition: opacity 0.36s, transform 0.36s;
}

/* Show the checkmark */
.save-btn .checkmark.show {
  opacity: 1;
  transform: scale(1);
}


.button-muted{ padding:10px 14px; border-radius:8px; background:#222; color:#fff; border:0 }

/* ===== CARD COMPONENTS ===== */
.cards { display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:16px }
/* Base flat accent style */
.comp-card {
  background: #202225;
  border-left: 6px solid transparent;
  border-radius: 10px;
  padding: 14px;
  color: #fff;
  box-shadow: 0 4px 14px rgba(0,0,0,0.5);
  transition: all 0.25s ease;
position: relative;        /* add this so ::before works */
  overflow: hidden;          /* keeps glow tidy inside corners */
}

.comp-card:hover {
 background: #26282b;
  transform: translateY(-3px);
}

.comp-card::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 6px;
  border-radius: 10px 0 0 10px;
  box-shadow: 0 0 8px currentColor;
  opacity: 0.4;
}

.comp-card .card-title { font-size:18px; font-weight:900; margin-bottom:8px }
.comp-card .big { font-size:18px; font-weight:800 }
.comp-card .small { font-size:13px; color:rgba(255,255,255,0.85) }

.comp-demons { border-left-color: #9b4dff; }
.comp-dragons { border-left-color: #ff6b6b; }
.comp-mechs { border-left-color: #f4d03f; }
.comp-murlocs { border-left-color: #2ecc71; }
.comp-quilboar { border-left-color: #d35400; }
.comp-pirates { border-left-color: #95a5a6; }
.comp-beasts { border-left-color: #27ae60; }
.comp-elementals { border-left-color: #3498db; }
.comp-undead { border-left-color: #2c3e50; }
.comp-naga { border-left-color: #1e90ff; }
.comp-menagerie { border-left-color: #8e44ad; }


/* subtle overlay stripe effect to give depth */
.comp-card::after { content:""; position:absolute; inset:0; pointer-events:none; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08)); mix-blend-mode: overlay; }

.comp-card:hover { transform: translateY(-6px); box-shadow: 0 14px 40px rgba(0,0,0,0.55); }

.small { font-size:14px; color:#cccccc }
.big { font-weight:700; font-size:24px }
.card-title { font-size:22px; font-weight:700; margin-bottom:8px }
canvas { width:100%; display:block }

/* check, modal, toast */
.checkmark{width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;opacity:0;transform:scale(0.6);transition:all .36s}
.checkmark.show{opacity:1;transform:scale(1)}
.modal-bg{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;padding:12px}
.modal{background:#0b0b0b;padding:12px;border-radius:10px;max-width:720px;width:100%;max-height:80vh;overflow:auto}
.match-row{display:flex;justify-content:space-between;gap:8px;align-items:center;padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)}
.del-btn{background:#3a2b2b;border:0;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#111;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04)}

/* ===== CANVAS GLOW EFFECT ===== */
.canvas-glow {  }

/* responsive tweak so that canvas height can be set in script reliably */
.chart-canvas { display:block; width:100%; height:auto; }

.custom-select {
  width: 100%;           /* full width on mobile */
  max-width: 200px;      /* optional max width */
  padding: 8px 12px;    /* comfortable touch target */
  font-size: 14px;       /* readable on small screens */
  border-radius: 8px;    /* rounded corners */
  border: 1px solid #ccc;
  background: #222;      /* match your dark theme */
  color: #fff;
  appearance: none;      /* remove default arrow */
  -webkit-appearance: none;
  -moz-appearance: none;
  cursor: pointer;
margin-top: 12px;
}

.custom-select:focus {
  outline: none;
  border-color: #00ff99;
  box-shadow: 0 0 0 2px rgba(0, 255, 153, 0.2);
}

#matchesDonutChart {
  width: 100%;
  height: 300px;
  max-height: 400px;
}

#placementLineChart {
  width: 100%;
  height: 260px; /* more vertical space */
  margin-left: -20px; /* shifts chart left to open up space */
}

#timeRange {
  margin-bottom: 8px;
}


.time-filter-btn {
  padding: 10px 14px;           /* same padding as input buttons */
  font-size: 14px;              /* slightly smaller than main save button */
  font-weight: 700;
  border-radius: 8px;
  border: 0;                     /* no border, consistent with input buttons */
  background: #222;              /* dark input-style background */
  color: #fff;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
}

.time-filter-btn:hover {
  background: #333;              /* subtle hover effect */
}

.time-filter-btn.active {
  background: linear-gradient(135deg, #00ff99, #00cccc);
  color: #000;
}


.section-separator {
  height: 2px;
  width: 100%;
  background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,0.2), rgba(255,255,255,0));
  margin: 28px 0; /* larger vertical spacing between input & display */
  border-radius: 1px;
}




</style>
</head>
<body>

<div class="headingTitle">BG TRACKER</div>
<div class="heading">Match Entry</div>
<div class="input-section" id="input-card">
  <div class="small">Composition</div>
  <div class="grid" id="composition-chips"></div>
  <div class="small" style="margin-top:10px">Place</div>
  <div class="grid" id="places"></div>
  <div class="small" style="margin-top:10px">Tier 3 Turn</div>
  <div class="grid" id="tier-buttons"></div>
  <div class="save-wrap"><button class="save-btn" id="save-match">Save Match <span id="save-check" class="checkmark" aria-hidden="true">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2fe0a8" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 12.5l5 4L20 6"/>
    </svg>
  </span></button>
</div>

<div class="section-separator"></div>



<!-- DROP DOWN MOVED ABOVE SUMMARY (user requested) -->
<div id="timeRangeFilters" style="display:flex; gap:8px; flex-wrap:nowrap; margin-bottom:8px;">
  <button class="time-filter-btn" data-range="10">Last 10</button>
  <button class="time-filter-btn" data-range="25">25</button>
  <button class="time-filter-btn" data-range="50">50</button>
  <button class="time-filter-btn" data-range="100">100</button>
  <button class="time-filter-btn" data-range="all">All Matches</button>
</div>


<!-- Summary panel with Winrate -->
<div id="summary" class="summary-panel" aria-live="polite">
  <div class="stat"><span class="label">Total</span><span id="totalMatches" class="value">0</span></div>
  <div class="stat"><span class="label">Avg</span><span id="avgPlacementOverall" class="value">-</span></div>
  <div class="stat"><span class="label">Winrate</span><span id="winrate" class="value">0%</span></div>
</div>

<!-- Placements (moved to be the first graph after summary) -->
<div class="heading">Placements</div>
<div class="chart-section">
  <canvas id="placementLineChart"></canvas>
</div>

 <!-- Matches per Composition (moved below Avg placement) -->
<div class="heading">Matches per Comp</div>
<div class="chart-section">
  <canvas id="matchesDonutChart"></canvas>
</div>

<div class="heading">Winrate per Comp</div>
<div class="chart-section">
  <canvas id="winrateBarChart" style="width:100%;height:220px"></canvas>
</div>

<!-- Average Placement by Composition (now after Placement Over Time) -->
<div class="heading">Average Placements</div>
<div class="chart-section"><canvas id="avg-place-chart" class="canvas-glow chart-canvas"></canvas></div>

<div class="heading">Avg. Placement by Tier 3 Turn</div>
<div class="chart-section"><canvas id="tier-chart" class="canvas-glow chart-canvas"></canvas></div>

<div class="heading">Composition Stats</div>
<div style="margin-bottom:10px">
  <label for="sort-cards">Sort by: </label>
  <select id="sort-cards" class="custom-select">
    <option value="matches">Number of matches</option>
    <option value="avg">Average placement</option>
  </select>
</div>

<div class="stats-section"><div class="cards" id="cards"></div></div>

<div style="display:flex;gap:10px;margin-top:8px">
  <button id="import-data" class="button-muted">Import Data</button>
  <button id="clear-data" class="button-muted">Clear Data</button>
  <button id="show-all" class="button-muted">Show All Matches</button>
</div>

<div id="modal-bg" class="modal-bg" style="display:none"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>

<script>
const COMPS=['Demons','Dragons','Mechs','Murlocs','Quilboar','Pirates','Beasts','Elementals','Undead','Naga','Menagerie'];
const TIER3=[3,4,5,6];
let state = {
  comp: COMPS[0],
  place: 1,
  tier: '3',
  matches: [],
  sortBy: 'matches' // default sort by number of matches
};
let db;

function openDb(){return new Promise(r=>{const req=indexedDB.open('bg-db',1);req.onupgradeneeded=e=>{const d=e.target.result;if(!d.objectStoreNames.contains('matches'))d.createObjectStore('matches',{keyPath:'id'});};req.onsuccess=e=>{db=e.target.result;r()};});}
function addMatch(m){return new Promise(r=>{const tx=db.transaction('matches','readwrite');tx.objectStore('matches').put(m);tx.oncomplete=()=>r();});}
function deleteMatch(id){return new Promise((res,rej)=>{const tx=db.transaction('matches','readwrite');tx.objectStore('matches').delete(id);tx.oncomplete=()=>res();tx.onerror=(e)=>rej(e);});}
function getAll(){return new Promise(r=>{const tx=db.transaction('matches','readonly');tx.objectStore('matches').getAll().onsuccess=e=>r(e.target.result||[]);});}
function clearAll(){return new Promise(r=>{const tx=db.transaction('matches','readwrite');tx.objectStore('matches').clear();tx.oncomplete=()=>r();});}
function uid(){return Date.now().toString()+'_'+Math.random().toString(36).slice(2,6)}

function buildUI(){
  const compEl=document.getElementById('composition-chips');compEl.innerHTML='';COMPS.forEach(c=>{const d=document.createElement('div');d.className='chip';d.textContent=c;d.onclick=()=>{state.comp=c;render()};compEl.appendChild(d)});
  const pEl=document.getElementById('places');pEl.innerHTML='';for(let i=1;i<=8;i++){const b=document.createElement('button');b.className='select-btn';b.textContent=i;b.onclick=()=>{state.place=i;render()};pEl.appendChild(b)}
  const tierEl=document.getElementById('tier-buttons');tierEl.innerHTML='';TIER3.forEach(t=>{const b=document.createElement('button');b.className='select-btn';b.textContent=t;b.onclick=()=>{state.tier=t;render()};tierEl.appendChild(b)})
}

function render(){document.querySelectorAll('#composition-chips .chip').forEach(el=>el.classList.toggle('active',el.textContent===state.comp));document.querySelectorAll('#places .select-btn').forEach((b,i)=>b.classList.toggle('active',i+1===state.place));document.querySelectorAll('#tier-buttons .select-btn').forEach(b=>b.classList.toggle('active',b.textContent==state.tier))}

/* single save handler kept (prevents duplicates) */
document.getElementById('save-match').onclick = async () => {
  const m = {
    id: uid(),
    composition: state.comp,
    place: state.place,
    play: state.play,
    tier: state.tier,
    created: Date.now()
  };

  await addMatch(m);
  await refresh();

  const backedUp = await backupData();
  if (backedUp) {
    toast('Match saved and backed up');
  } else {
    toast('Match saved (backup unavailable)');
  }

  showCheck();
};

function toast(msg){const t=document.createElement('div');t.className='toast';t.textContent=msg;document.body.appendChild(t);setTimeout(()=>t.remove(),1600)}

/* ------------------------------------------
   PERSISTENT Local Backup System + Fallback
------------------------------------------ */
let backupFileHandle = null;
let backupSupported = 'showSaveFilePicker' in window;

// ✅ Check browser support and warn if not available
if (!backupSupported) {
  console.warn('File System Access API not supported — using fallback backup system.');
}

// --- Helper: small IndexedDB just to store file handle ---
async function openHandleDb() {
  return new Promise((resolve) => {
    const req = indexedDB.open('bg-backup-handle-db', 1);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
    };
    req.onsuccess = (e) => resolve(e.target.result);
  });
}

async function saveBackupHandle(handle) {
  try {
    const db = await openHandleDb();
    const tx = db.transaction('handles', 'readwrite');
    tx.objectStore('handles').put(handle, 'backup');
  } catch (err) {
    console.warn('Could not store handle:', err);
  }
}

async function getSavedBackupHandle() {
  try {
    const db = await openHandleDb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('handles', 'readonly');
      const req = tx.objectStore('handles').get('backup');
      req.onsuccess = () => resolve(req.result);
      req.onerror = reject;
    });
  } catch (err) {
    console.warn('Handle retrieval failed:', err);
    return null;
  }
}

// --- Let user choose backup file manually (first time only) ---
async function chooseBackupFile() {
  if (!backupSupported) {
    toast('Your browser does not support automatic local backups. Use Export Data instead.');
    return;
  }

  try {
    backupFileHandle = await window.showSaveFilePicker({
      suggestedName: 'bg-tracker-backup.json',
      types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
    });
    await saveBackupHandle(backupFileHandle);
    toast('Backup file selected and stored');
  } catch (e) {
    console.warn('User canceled file selection:', e);
  }
}

// --- Restore stored handle if available ---
async function restoreBackupHandle() {
  if (!backupSupported) return;
  const savedHandle = await getSavedBackupHandle();
  if (!savedHandle) return;
  try {
    const perm = await savedHandle.queryPermission({ mode: 'readwrite' });
    if (perm === 'granted' || (await savedHandle.requestPermission({ mode: 'readwrite' })) === 'granted') {
      backupFileHandle = savedHandle;
      console.log('Backup handle restored.');
    }
  } catch (err) {
    console.warn('Restore failed:', err);
  }
}

// --- Perform the actual backup ---
async function backupData() {
  const allMatches = await getAll();

  // Case 1: supported browser with stored handle
  if (backupFileHandle) {
    try {
      const writable = await backupFileHandle.createWritable();
      await writable.write(JSON.stringify(allMatches, null, 2));
      await writable.close();
      console.log('Backup file updated successfully');
      return true;
    } catch (e) {
      console.error('Backup failed:', e);
      return false;
    }
  }

  // Case 2: Fallback for unsupported browsers (auto-download JSON)
  if (!backupSupported) {
    try {
      const blob = new Blob([JSON.stringify(allMatches, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'bg-tracker-backup-' + new Date().toISOString().slice(0, 10) + '.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      console.log('Backup exported (fallback)');
      return true;
    } catch (e) {
      console.warn('Fallback backup failed:', e);
    }
  }

  return false;
}

// --- Add a manual setup button at the bottom next to other action buttons ---
const backupBtn = document.createElement('button');
backupBtn.textContent = 'Setup Backup File';
backupBtn.className = 'button-muted';
backupBtn.onclick = chooseBackupFile;

// Append to the bottom buttons container
const bottomButtonsContainer = document.querySelector('div[style*="display:flex"][style*="margin-top:8px"]');
if (bottomButtonsContainer) {
  bottomButtonsContainer.appendChild(backupBtn);
}



// --- Try restoring previous handle automatically ---
(async () => {
  await restoreBackupHandle();
})();

/* ------------------------------------------
   Confirm Before Clearing All Data
------------------------------------------ */
document.getElementById('clear-data').onclick = async () => {
  if (!confirm('Are you sure you want to delete all match data? This cannot be undone.')) return;
  await clearAll();
  await refresh();
  toast('All data cleared');
};


/* ------------------------------------------
   UI / Cards / Charts / Helpers
------------------------------------------ */

function computeAvg(arr){return arr.length?arr.reduce((a,b)=>a+b,0)/arr.length:null}
function mostCommon(arr){if(!arr.length) return '-';const f={};arr.forEach(a=>f[a]=(f[a]||0)+1);return Object.keys(f).reduce((a,b)=>f[a]>=f[b]?a:b)}

/* Return matches filtered by the current timeRange dropdown (applies to all charts) */
function getFilteredMatches(allMatches) {
  const rangeSel = document.getElementById('timeRange');
  if (!rangeSel) return allMatches;
  const rangeVal = rangeSel.value;
  let matches = [...allMatches].sort((a, b) => a.created - b.created);
  if (rangeVal !== 'all') {
    const limit = parseInt(rangeVal);
    matches = matches.slice(-limit);
  }
  return matches;
}

function renderCards(){
  const cards = document.getElementById('cards');
  cards.innerHTML = '';

  // Use the whole state.matches for cards (cards are summary across all data) — unchanged behavior
  const compStats = COMPS.map(c => {
    const ms = state.matches.filter(m => m.composition === c);
    const avg = computeAvg(ms.map(m => m.place));
    const avgTier = computeAvg(ms.map(m => m.tier === '—' ? 0 : m.tier));
    return { name: c, matches: ms.length, avg, avgTier };
  });

  // Sort compositions based on state.sortBy
  if(state.sortBy === 'matches'){
    compStats.sort((a,b) => b.matches - a.matches); // descending
  }else if(state.sortBy === 'avg'){
    compStats.sort((a,b) => a.avg - b.avg); // ascending: lower placement is better
  }

  // Render in the new order
  compStats.forEach(stat => {
    const div = document.createElement('div');
    div.className = 'comp-card comp-' + stat.name.toLowerCase();
    div.innerHTML = `
      <div class="card-title">${stat.name}</div>
      <div class="big">Avg: ${stat.matches ? stat.avg.toFixed(2) : '-'}</div>
      <div class="small">Matches: ${stat.matches}</div>
      <div class="small">Avg Tier 3 Turn: ${stat.matches ? stat.avgTier.toFixed(1) : '-'}</div>
    `;
    div.onclick = () => openDetails(stat.name);
    cards.appendChild(div);
  });
}

// modal functions
const modalBg=document.getElementById('modal-bg');
async function openDetails(comp){modalBg.innerHTML='';const box=document.createElement('div');box.className='modal';box.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><div style="font-weight:900">${comp} — matches</div><button id="modal-close" class="button-muted">Close</button></div><div id="modal-body"></div>`;modalBg.appendChild(box);document.getElementById('modal-close').onclick=()=>modalBg.style.display='none';modalBg.onclick=(e)=>{if(e.target===modalBg)modalBg.style.display='none'};const body=document.getElementById('modal-body');const matches=(await getAll()).filter(m=>m.composition===comp).sort((a,b)=>b.created-a.created);if(matches.length===0){body.innerHTML='<div class="small">No matches recorded for this composition.</div>'}else{matches.forEach(m=>{const row=document.createElement('div');row.className='match-row';const left=document.createElement('div');left.innerHTML=`<div style="font-weight:800">Place ${m.place}</div><div class="small">Tier ${m.tier==='—'?'—':m.tier}</div><div class="small">${new Date(m.created).toLocaleString()}</div>`;const del=document.createElement('button');del.className='del-btn';del.textContent='Delete';del.onclick=async(e)=>{e.stopPropagation();await deleteMatch(m.id);await refresh();openDetails(comp);toast('Deleted')};row.appendChild(left);row.appendChild(del);body.appendChild(row)})}modalBg.style.display='flex'}

// show all matches modal and allow delete
async function openAllMatches(){modalBg.innerHTML='';const box=document.createElement('div');box.className='modal';box.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><div style="font-weight:900">All Matches</div><button id="modal-close-all" class="button-muted">Close</button></div><div id="modal-body-all"></div>`;modalBg.appendChild(box);document.getElementById('modal-close-all').onclick=()=>modalBg.style.display='none';modalBg.onclick=(e)=>{if(e.target===modalBg)modalBg.style.display='none'};const body=document.getElementById('modal-body-all');const matches=(await getAll()).sort((a,b)=>b.created-a.created);if(matches.length===0){body.innerHTML='<div class="small">No matches recorded.</div>'}else{matches.forEach(m=>{const row=document.createElement('div');row.className='match-row';const left=document.createElement('div');left.innerHTML=`<div style="font-weight:800">${m.composition} • Place ${m.place}</div><div class="small">Tier ${m.tier==='—'?'—':m.tier}</div><div class="small">${new Date(m.created).toLocaleString()}</div>`;const del=document.createElement('button');del.className='del-btn';del.textContent='Delete';del.onclick=async(e)=>{e.stopPropagation();await deleteMatch(m.id);await refresh();openAllMatches();toast('Deleted')};row.appendChild(left);row.appendChild(del);body.appendChild(row)})}modalBg.style.display='flex'}

document.getElementById('show-all').onclick = ()=> openAllMatches();

/* C) Chart improvements: color mapping, glow, animation, shadow */

/* Colors aligned to composition gradient primary tones (keeps mapping minimal and consistent) */
const COMP_COLORS = {
  'Demons':'#9b4dff',
  'Dragons':'#ff6b6b',
  'Mechs':'#f4d03f',
  'Murlocs':'#2ecc71',
  'Quilboar':'#d35400',
  'Pirates':'#95a5a6',
  'Beasts':'#27ae60',
  'Elementals':'#3498db',
  'Undead':'#2c3e50',
  'Naga':'#1e90ff',
  'Menagerie':'#8e44ad'
};
/* Generic color set for playstyle / tier charts (keeps them visually cohesive) */
const TIER_COLORS = ['#dedc76', '#dedc76', '#dedc76', '#dedc76'];


function drawBarChartAnimated(canvas, items, colorForItemFn) {
  // Draw animated horizontal bars that grow. Uses devicePixelRatio scaling and shadow for "thick" shadow/glow.
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const rowHeight = 44;
  canvas.width = width * dpr;
  canvas.height = items.length * rowHeight * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,width,canvas.height/dpr);

  // precompute values & target widths
  const values = items.map(it => (it.value===null ? null : it.value));
  // For placement averages (1..8), smaller is better; we map 1->full width, 8->near zero
  function placementToRatio(v) { if(v===null) return 0; const r = (8 - v) / 7; return Math.max(0, Math.min(1, r)); }

  const targets = values.map(v => placementToRatio(v) * width);

  // animation variables
  const duration = 700; // ms
  const start = performance.now();

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  function frame(now){
    const t = Math.min(1, (now - start) / duration);
    const ease = easeOutCubic(t);
    ctx.clearRect(0,0,width,canvas.height/dpr);
    ctx.font = '14px Inter, system-ui, Arial, sans-serif';
    ctx.textBaseline = 'middle';

    items.forEach((it, i) => {
      const y = i * rowHeight + 6;
      const targetW = targets[i];
      const currentW = targetW * ease;
      const col = colorForItemFn ? colorForItemFn(it, i) : '#fff';

      // thick shadow / glow
      ctx.save();
      ctx.fillStyle = col;
      ctx.shadowColor = col;
      ctx.shadowBlur = 6; // glow
      ctx.fillRect(0, y, currentW, 32);
      ctx.restore();

      // draw border outline
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 2;
      ctx.strokeRect(0.5, y + 0.5, Math.max(0.1, currentW - 1), 32 - 1);

      // label
      ctx.fillStyle = '#ffffff';
      const labelText = `${it.name} (${it.matches? (it.value===null ? '-' : it.value.toFixed(2)) : '-'})`;
      ctx.fillText(labelText, 8, y + 16);
    });

    if (t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

 /* ==========================================
   Chart.js Charts (Responsive + Animated)
========================================== */

let donutChartInstance = null;
let lineChartInstance = null;

function drawDonutChart(filteredMatches) {
  const ctx = document.getElementById('matchesDonutChart');
  if (!ctx) return;

  const data = COMPS.map(c => ({
    name: c,
    value: filteredMatches.filter(m => m.composition === c).length
  })).filter(d => d.value > 0);

  if (donutChartInstance) donutChartInstance.destroy();

  donutChartInstance = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: data.map(d => d.name),
      datasets: [{
        data: data.map(d => d.value),
        backgroundColor: data.map(d => COMP_COLORS[d.name] || '#999'),
        borderWidth: 1,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom',
          labels: { color: '#fff' }
        },
        title: {
          display: false
        }
      }
    }
  });
}





function drawWinrateBarChart(filteredMatches) {
  const ctx = document.getElementById('winrateBarChart');
  if (!ctx) return;

  const data = COMPS.map(c => {
    const ms = filteredMatches.filter(m => m.composition === c);
    const total = ms.length;
    const top4 = ms.filter(x => Number(x.place) <= 4).length;
    const wr = total ? (top4 / total) * 100 : 0;
    return { name: c, value: wr, matches: total };
  }).filter(d => d.matches > 0)
    .sort((a, b) => b.value - a.value);

  if (ctx._chartInstance) ctx._chartInstance.destroy();

  ctx._chartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: data.map(d => d.name),
      datasets: [{
        data: data.map(d => 0), // Start at 0 for animation
        backgroundColor: data.map(d => COMP_COLORS[d.name]),
        borderRadius: 0,
        borderWidth: data.map(d => d.value >= 50 ? 2 : 0),
        borderColor: data.map(d => d.value >= 50 ? '#fff' : 'transparent'),
        barPercentage: 0.9,
        categoryPercentage: 0.95
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: 'x',
      scales: {
        x: {
          grid: { display: false },
          ticks: { display: false }
        },
        y: {
          min: 0,
          max: 100,
          grid: {
            drawTicks: false,
            color: (ctx) => ctx.tick.value === 50 ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0)',
            lineWidth: (ctx) => ctx.tick.value === 50 ? 3 : 0
          },
          ticks: {
            display: false
          },
          border: { display: false }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.label}: ${ctx.formattedValue}% winrate (${data[ctx.dataIndex].matches} matches)`
          },
          backgroundColor: 'rgba(0,0,0,0.85)',
          titleColor: '#00ff99',
          bodyColor: '#fff'
        },
        annotation: {
          annotations: {
            fiftyLine: {
              type: 'line',
              yMin: 50,
              yMax: 50,
              borderColor: '#ffffffcc',
              borderWidth: 3,
              label: {
                enabled: true,
                content: '50%',
                position: 'start',
                color: '#fff',
                backgroundColor: 'rgba(0,0,0,0.7)',
                font: { size: 11 }
              }
            }
          }
        }
      },
      animation: {
        duration: 0 // Disable default animation
      }
    },
    plugins: [{
      id: 'verticalTextPlugin',
      afterDatasetsDraw(chart) {
        const { ctx, data: chartData } = chart;
        ctx.save();
        ctx.font = '600 14px Inter, system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';

        chart.getDatasetMeta(0).data.forEach((bar, i) => {
          const val = chartData.datasets[0].data[i];
          const label = chartData.labels[i];
          const text = `${label} ${val.toFixed(1)}%`;
          const barHeight = chart.chartArea.bottom - bar.y;
          
          // Always draw text, allow overflow for short bars
          ctx.save();
          ctx.translate(bar.x, chart.chartArea.bottom - 8);
          ctx.rotate(-Math.PI / 2);
          ctx.fillText(text, 0, 0);
          ctx.restore();
        });
        ctx.restore();
      }
    }]
  });

  // Animate bars on scroll into view
  const observer = new IntersectionObserver(entries => {
    if (!entries[0].isIntersecting) return;
    ctx._chartInstance.data.datasets[0].data = data.map(d => d.value);
    ctx._chartInstance.options.animation = {
      duration: 900,
      easing: 'easeOutCubic'
    };
    ctx._chartInstance.update();
    observer.disconnect();
  }, { threshold: 0.25 });

  observer.observe(ctx);
}







function drawPlacementLineChart(filteredMatches) {
  const ctx = document.getElementById('placementLineChart');
  if (!ctx) return;

  const matches = [...filteredMatches].sort((a,b) => a.created - b.created);
  const labels = matches.map((_, i) => `#${i+1}`);
  const placements = matches.map(m => m.place ?? 8);

  // Colors based on win/loss
  const colors = placements.map(p => (p <= 4 ? '#00cc66' : '#ff4444'));

  // Transform placement: 1->8, 8->1 for bar height
  const heights = placements.map(p => 9 - p);

  if(lineChartInstance) lineChartInstance.destroy();

  lineChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Placement',
        data: heights,
        backgroundColor: colors,
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 800,
        easing: 'easeOutQuart'
      },
      scales: {
        x: { display: false },
        y: {
          min: 1,
          max: 8,
          ticks: {
            stepSize: 1,
            color: 'rgba(255,255,255,0.4)',
            font: { size: 11 },
            // Flip labels: show 1 at top, 8 at bottom
            callback: function(val) { return 9 - val; }
          },
          grid: { color: 'rgba(255,255,255,0.08)' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: { label: ctx => `Place ${placements[ctx.dataIndex]}` },
          backgroundColor: 'rgba(0,0,0,0.85)',
          titleColor: '#00ff99',
          bodyColor: '#fff'
        }
      }
    }
  });


  // Animate bars growing from bottom
  const observer = new IntersectionObserver(entries => {
    if (!entries[0].isIntersecting) return;
    lineChartInstance.data.datasets[1].data = topBar;
    lineChartInstance.options.animation = {
      duration: 800,
      easing: 'easeOutQuart'
    };
    lineChartInstance.update();
    observer.disconnect();
  }, { threshold: 0.25 });

  observer.observe(ctx);
}






function drawCharts(){
  // all charts must follow the dropdown selection -> get filtered matches
  const filteredMatches = getFilteredMatches(state.matches);

  // Placement line chart uses filteredMatches
  drawPlacementLineChart(filteredMatches);

  // Average placement per composition (map each comp to its color) using filteredMatches
  let compVals=COMPS.map(c=>{const ms=filteredMatches.filter(m=>m.composition===c);const avg=computeAvg(ms.map(m=>m.place));return{name:c,value:avg,matches:ms.length}});
  // sort by value similar as before (nulls last)
  compVals.sort((a,b)=>{if(a.value===null&&b.value===null)return 0;if(a.value===null)return 1;if(b.value===null)return -1;return a.value-b.value});
  const avgCanvas = document.getElementById('avg-place-chart');
  drawBarChartAnimated(avgCanvas, compVals, (it,i)=>COMP_COLORS[it.name] || '#fff');

  // Matches per composition donut using filteredMatches
  drawDonutChart(filteredMatches);

drawWinrateBarChart(filteredMatches);

  // Tier chart using filteredMatches
  let tierList=TIER3.filter(x=>'—'!==x);
  let tierVals=tierList.map(t=>{const ms=filteredMatches.filter(m=>m.tier==t);const avg=computeAvg(ms.map(m=>m.place));return{name:String(t),value:avg,matches:ms.length}});
  tierVals.sort((a,b)=>{if(a.value===null)return 1;if(b.value===null)return -1;return a.value-b.value});
  const tierCanvas = document.getElementById('tier-chart');
  drawBarChartAnimated(tierCanvas, tierVals, (it,i)=> TIER_COLORS[i % TIER_COLORS.length]);

  // Attach dropdown change to redraw all charts (only once)
  const tSel = document.getElementById('timeRange');
  if (tSel && !tSel._chartsBound) {
    tSel.addEventListener('change', () => {
      // redraw charts based on new selection
      drawCharts();
    });
    tSel._chartsBound = true;
  }
}

/* Update small summary section (A) */
function updateSummary() {
  const filteredMatches = getFilteredMatches(state.matches); // use filtered data
  const total = filteredMatches.length || 0;
  const avg = computeAvg(filteredMatches.map(m => m.place));
  const top4 = filteredMatches.filter(m => Number(m.place) <= 4).length;
  const winrate = total ? (top4 / total * 100).toFixed(1) : 0;

  document.getElementById('totalMatches').textContent = total;
  document.getElementById('avgPlacementOverall').textContent = avg ? avg.toFixed(2) : '-';
  document.getElementById('winrate').textContent = `${winrate}%`;

  // optional: color code winrate
  const winEl = document.getElementById('winrate');
  if (total === 0) {
    winEl.style.color = '#00ffcc';
  } else if (winrate >= 60) {
    winEl.style.color = '#7CFFB2';
  } else if (winrate >= 40) {
    winEl.style.color = '#FFD36B';
  } else {
    winEl.style.color = '#FF7B7B';
  }
}


document.getElementById('sort-cards').onchange = (e) => {
  state.sortBy = e.target.value;
  renderCards();
}

/* initialize */
(async()=>{await openDb();buildUI();render();await refresh()})();

/* showCheck helper (animates checkmark) */
function showCheck(){
  const el = document.getElementById('save-check');
  if(!el) return;
  el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'), 1200);
}

// import
const importBtn=document.getElementById('import-data');importBtn.onclick=()=>{const input=document.createElement('input');input.type='file';input.accept='application/json';input.onchange=async()=>{const file=input.files[0];if(!file)return;const text=await file.text();try{const arr=JSON.parse(text);const tx=db.transaction('matches','readwrite');const store=tx.objectStore('matches');arr.forEach(m=>{if(!m.id)m.id=uid();store.put(m)});tx.oncomplete=()=>refresh()}catch(err){alert('Import failed: '+err.message)}};input.click()};

/* refresh wrapper */
async function refresh(){state.matches=await getAll();renderCards();drawCharts();updateSummary();}

</script>
  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js')
    .then(() => console.log('Service Worker registered!'))
    .catch(err => console.log('Service Worker failed:', err));
}

// initialize filter buttons
const timeButtons = document.querySelectorAll('.time-filter-btn');
timeButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    // remove active from all
    timeButtons.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    // update filter
    const rangeVal = btn.dataset.range;
    state.timeRange = rangeVal; // store selected range

    drawCharts();
    updateSummary();
  });
});

// Optional: set default selection to "Last 10"
const defaultBtn = document.querySelector('.time-filter-btn[data-range="10"]');
if(defaultBtn) defaultBtn.click();

// Modify getFilteredMatches to check state.timeRange
function getFilteredMatches(allMatches) {
  const rangeVal = state.timeRange || '10'; // default to 10 if not set
  let matches = [...allMatches].sort((a, b) => a.created - b.created);
  if (rangeVal !== 'all') {
    const limit = parseInt(rangeVal);
    matches = matches.slice(-limit);
  }
  return matches;
}




</script>




</body>
</html>
